program ::= global-decl-list

global-decl-list ::= global-decl-list global-decl | nil

global-decl ::= let-decl
              | type-decl

let-decl ::= 'let' (normal-decl | native-decl)

normal-decl ::= 'rec'? let-assign-list

native-decl ::= 'native' identifier '=' string

type-decl ::= 'type' identifier '=' type-definition

type-definition ::= type-constructor-list
                  | 'native' string

type-constructor-list ::= type-constructor-list '|' type-constructor
                        | type-constructor

type-constructor ::= identifier identifier*

let-assign-list ::= let-assign-list let-assign | nil

let-assign ::= identifier '=' expr

expr ::= application-expr | non-application-expr

non-application-expr ::= integer
                       | float
                       | 'true' | 'false'
                       | string
                       | identifier
                       | abstraction-expr
                       | application-expr
                       | let-expr
                       | stmt-list
                       | return-expr
                       | break-expr
                       | continue-expr
                       | if-expr
                       | loop-expr
                       | '(' expr ')'

abstraction-expr ::= ('\\' | 'lambda') (identifier+ | '()') '.' expr

application-expr ::= non-application-expr expr-list

let-expr ::= 'let' 'rec'? let-assign-list 'in' expr

stmt-list ::= 'begin' semicolon-sep-expr-list 'end'

return-expr ::= 'return' expr?

break-expr ::= 'break' expr?

continue-expr ::= 'continue'

if-expr ::= 'if' expr 'then' expr ('else' expr)?

loop-expr ::= 'loop' expr 'end'

expr-list ::= expr-list expr | nil

semicolon-sep-expr-list ::= semicolon-sep-expr-list ';' expr | expr
